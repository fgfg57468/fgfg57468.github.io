<html lang="ru">
<script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.js"></script>
<style>
    .galleria{ width: auto; height: 400px; background: #fff }
</style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Парсер Telegram</title>
    <!-- Подключение Galleria -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/galleria/1.6.1/themes/classic/galleria.classic.min.css">
    <style>
        /* Стили для Galleria и постов */
        .galleria-container { 
            width: 100%; 
            height: 400px; 
            margin: 20px 0;
            display: block; 
        }
        .post-group { 
            margin: 20px 0; 
            padding: 15px; 
            border: 1px solid #ddd; 
            border-radius: 8px; 
        }
        .hidden { display: none; }
        .no-title { color: #999; font-style: italic; }
        .error { color: red; padding: 10px; background: #ffe6e6; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="telegram-posts-container"></div>

    <!-- Подключение библиотек -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/galleria/1.6.1/galleria.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/galleria/1.6.1/themes/classic/galleria.classic.min.js"></script>

    <script>
        // === КОНФИГУРАЦИЯ ===
        const TELEGRAM_CONFIG = { 
            channel: 'site_files', 
            // Список прокси для резервирования
            proxies: [
                'https://api.allorigins.win/get?url=',
                'https://api.codetabs.com/v1/proxy?quest=',
                'https://cors-anywhere.herokuapp.com/'
            ]
        };

        // === ФУНКЦИЯ ДЛЯ ПОПЫТКИ ЗАПРОСА ЧЕРЕЗ РАЗНЫЕ ПРОКСИ ===
        async function tryFetchWithProxies(url, proxies) {
            let lastError = null;
            
            for (const proxy of proxies) {
                try {
                    console.log(`Пробуем прокси: ${proxy}`);
                    const proxyUrl = proxy + encodeURIComponent(url);
                    const response = await fetch(proxyUrl, {
                        // Добавляем таймаут для запроса
                        signal: AbortSignal.timeout(10000)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Проверяем, что данные есть
                    if (data && data.contents) {
                        console.log(`Успешный запрос через прокси: ${proxy}`);
                        return data.contents;
                    } else {
                        throw new Error('Пустой ответ от прокси');
                    }
                } catch (error) {
                    console.warn(`Прокси ${proxy} не сработал:`, error.message);
                    lastError = error;
                    // Продолжаем пробовать следующий прокси
                }
            }
            
            // Если все прокси не сработали
            throw new Error(`Все прокси не сработали. Последняя ошибка: ${lastError?.message}`);
        }

        // === ОСНОВНАЯ ФУНКЦИЯ ПАРСИНГА ===
        async function parseTelegramChannel(config) {
            const url = `https://t.me/s/${config.channel}`;
            
            try {
                console.log('Начинаем парсинг канала:', url);
                const html = await tryFetchWithProxies(url, config.proxies);
                
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const posts = [];
                const messageElements = doc.querySelectorAll('.tgme_widget_message');

                console.log(`Найдено элементов сообщений: ${messageElements.length}`);

                messageElements.forEach(messageEl => {
                    const bubbleEl = messageEl.querySelector('.tgme_widget_message_bubble');
                    if (!bubbleEl) return;
                    
                    const linkEl = messageEl.querySelector('a.tgme_widget_message_date');
                    const postUrl = linkEl?.href || '';
                    const idMatch = postUrl.match(/\/(\d+)$/);
                    const id = idMatch ? idMatch[1] : '';
                    
                    const timeEl = messageEl.querySelector('time');
                    const datetime = timeEl?.dateTime || '';
                    
                    let text = '';
                    const textEl = bubbleEl.querySelector('.tgme_widget_message_text');
                    if (textEl) text = textEl.textContent || textEl.innerText || '';
                    
                    const hashtags = text.match(/#[\w\u0410-\u044F\u0401\u0451]+/gi) || [];
                    const cleanHashtags = [...new Set(hashtags.map(tag => tag.replace('#', '').toLowerCase()))];
                    
                    const images = [];
                    const photoElements = bubbleEl.querySelectorAll('.tgme_widget_message_photo_wrap, .tgme_widget_message_photo');
                    photoElements.forEach(photo => {
                        const bgImage = photo.style.backgroundImage;
                        const urlMatch = bgImage?.match(/url\(['"]?(.*?)['"]?\)/i);
                        if (urlMatch && urlMatch[1]) {
                            let imgUrl = urlMatch[1];
                            if (imgUrl.startsWith('//')) imgUrl = 'https:' + imgUrl;
                            if (!images.includes(imgUrl)) images.push(imgUrl);
                        }
                    });

                    if (text.trim() || images.length > 0) {
                        posts.push({ 
                            id: id, 
                            url: postUrl, 
                            datetime: datetime, 
                            text: text.trim(), 
                            hashtags: cleanHashtags, 
                            images: images, 
                            timestamp: new Date(datetime).getTime() 
                        });
                    }
                });

                console.log(`Собрано постов: ${posts.length}`);
                posts.sort((a, b) => b.timestamp - a.timestamp);
                return posts;
                
            } catch (error) {
                console.error('Ошибка при парсинге канала:', error);
                throw new Error(`Не удалось загрузить данные: ${error.message}`);
            }
        }

        // === ФУНКЦИЯ ГРУППИРОВКИ ПО ХЕШТЕГАМ ===
        function groupPostsByHashtags(posts) {
            const groups = {};
            let renderOrderPost = null;
            
            // Фильтруем посты: убираем посты без хештегов и с хештегом "порядок_рендеринга"
            const filteredPosts = posts.filter(post => {
                // Пропускаем посты без хештегов
                if (post.hashtags.length === 0) return false;
                
                // Пропускаем посты с хештегом "порядок_рендеринга"
                if (post.hashtags.includes('порядок_рендеринга')) {
                    if (!renderOrderPost || post.timestamp > renderOrderPost.timestamp) {
                        renderOrderPost = post;
                    }
                    return false;
                }
                
                return true;
            });

            console.log(`Постов после фильтрации: ${filteredPosts.length}`);

            // Группируем отфильтрованные посты
            filteredPosts.forEach(post => {
                const groupHashtags = post.hashtags.filter(tag => tag !== 'порядок_рендеринга');
                if (groupHashtags.length === 0) return;

                const groupKey = groupHashtags.sort().join('|');
                if (!groups[groupKey]) {
                    groups[groupKey] = { 
                        hashtags: groupHashtags, 
                        posts: [], 
                        combinedText: '', 
                        allImages: [],
                        title: ''
                    };
                }
                groups[groupKey].posts.push(post);
            });

            // Обрабатываем каждую группу
            Object.values(groups).forEach(group => {
                group.posts.sort((a, b) => a.timestamp - b.timestamp);
                
                // Убираем хештеги из текста при объединении
                group.combinedText = group.posts.map(post => {
                    // Удаляем все хештеги из текста
                    let cleanText = post.text.replace(/#[\w\u0410-\u044F\u0401\u0451]+/gi, '').trim();
                    // Убираем лишние пробелы
                    cleanText = cleanText.replace(/\s+/g, ' ').trim();
                    return cleanText;
                }).filter(text => text).join('\n\n');
                
                // Извлекаем название из первого поста в группе
                if (group.posts.length > 0) {
                    const firstPost = group.posts[0];
                    // Название - первая строка текста (до переноса строки)
                    const firstLine = firstPost.text.split('\n')[0];
                    // Убираем хештеги из названия
                    const cleanTitle = firstLine.replace(/#[\w\u0410-\u044F\u0401\u0451]+/gi, '').trim();
                    // Если после очистки остался текст - используем его, иначе "Название отсутствует"
                    group.title = cleanTitle || 'Название отсутствует';
                } else {
                    group.title = 'Название отсутствует';
                }
                
                group.allImages = group.posts.flatMap(post => post.images);
            });

            return { groups: groups, renderOrderPost: renderOrderPost };
        }

        // === ФУНКЦИЯ ИНИЦИАЛИЗАЦИИ GALLERIA ДЛЯ КОНКРЕТНОГО КОНТЕЙНЕРА ===
        function initGalleriaForContainer(containerId, images, title) {
            const container = document.getElementById(containerId);
            if (images.length === 0) { 
                console.log('Нет изображений для галереи'); 
                return; 
            }
            
            // Создаем данные для Galleria
            const galleriaData = images.map(imgUrl => ({
                image: imgUrl,
                title: title
            }));
            
            // Инициализируем Galleria с небольшой задержкой
            setTimeout(() => {
                try {
                    Galleria.run(`#${containerId}`, { 
                        dataSource: galleriaData, 
                        //responsive: true, 
                        //height: 0.666
                        //theme: 'folio'
                    });
                    console.log(`Galleria инициализирована для ${containerId}`);
                } catch (error) {
                    console.error(`Ошибка при инициализации Galleria для ${containerId}:`, error);
                }
            }, 100);
        }

        // === ГЛАВНАЯ ФУНКЦИЯ ИНИЦИАЛИЗАЦИИ ===
        async function initTelegramParser(containerId, config = {}) {
            const finalConfig = { ...TELEGRAM_CONFIG, ...config };
            const container = document.getElementById(containerId);
            if (!container) { 
                console.error(`Контейнер не найден`); 
                return; 
            }
            
            container.innerHTML = '<div>Загрузка постов... (это может занять несколько секунд)</div>';
            
            try {
                const posts = await parseTelegramChannel(finalConfig);
                
                if (posts.length === 0) { 
                    container.innerHTML = '<div class="error">Посты не найдены или канал недоступен</div>'; 
                    return; 
                }
                
                const { groups, renderOrderPost } = groupPostsByHashtags(posts);
                container.innerHTML = '';
                
                if (Object.keys(groups).length === 0) {
                    container.innerHTML = '<div>Нет подходящих постов для отображения</div>';
                    return;
                }
                
                // Создаем контейнеры и галереи для каждой группы
                Object.values(groups).forEach((group, index) => {
                    // Пропускаем группы без контента
                    if (!group.combinedText && group.allImages.length === 0) return;
                    
                    const groupId = `group-${index}`;
                    const galleryId = `gallery-${index}`;
                    
                    // Создаем контейнер для группы
                    const groupElement = document.createElement('div');
                    groupElement.className = 'post-group';
                    groupElement.id = groupId;
                    
                    // Добавляем класс если название отсутствует
                    const titleClass = group.title === 'Название отсутствует' ? 'no-title' : '';
                    
                    // Заполняем содержимое группы
                    groupElement.innerHTML = `
                        <h3 class="${titleClass}">${group.title}</h3>
                        ${group.combinedText ? `<p>${group.combinedText.replace(/\n/g, '<br>')}</p>` : ''}
                        ${group.allImages.length > 0 ? 
                            `<div id="${galleryId}" class="galleria-container"></div>` : 
                            '<p>Нет изображений в этой группе</p>'
                        }
                    `;
                    
                    container.appendChild(groupElement);
                    
                    // Инициализируем галерею для этой группы, если есть изображения
                    if (group.allImages.length > 0) {
                        initGalleriaForContainer(galleryId, group.allImages, group.title);
                    }
                });
                
                // Показываем статистику
                const stats = document.createElement('div');
                stats.innerHTML = `<p><small>Загружено групп: ${Object.keys(groups).length}</small></p>`;
                container.appendChild(stats);
                
            } catch (error) {
                console.error('Критическая ошибка:', error);
                container.innerHTML = `
                    <div class="error">
                        <strong>Ошибка загрузки данных:</strong><br>
                        ${error.message}<br><br>
                        <small>Попробуйте обновить страницу или проверьте подключение к интернету.</small>
                    </div>
                `;
            }
        }

        // Добавляем полифилл для AbortSignal.timeout если не поддерживается
        if (!AbortSignal.timeout) {
            AbortSignal.timeout = function(ms) {
                const controller = new AbortController();
                setTimeout(() => controller.abort(new Error("Timeout")), ms);
                return controller.signal;
            };
        }

        // Запуск после загрузки страницы
        document.addEventListener('DOMContentLoaded', () => initTelegramParser('telegram-posts-container'));
    </script>
</body>
</html>